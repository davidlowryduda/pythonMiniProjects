#!/usr/bin/env python3.3

"""
.. module:: sacksSpiral
    Synopsis
    --------
    Sack's Spiral is sort of a co-Ulam Spiral (co in the mathematical sense).
    Numbers are plotted counterclockwise in a spiral, where n gets polar
    coordinates (sqrt(n), 2*pi*sqrt(n)). And they are given a radius
    2^(nu(n)-1), where nu(n) is the number of distinct prime factors.

    Pretty patterns emerge. The output is in file spirals.py.

    CAUTION
    -------
    Do not use in directories with files called "label.ps" or "tt_spiral*.ps",
    as these are deleted at the conclusion of the program.

.. author:: David Lowry-Duda <djlowry@math.brown.edu>

Copyright (c) 2013, 2014, David Lowry-Duda
All rights reserved."""

from pyx import *
from entDLD import *
import os
import math

# Number of points to plot
n = 10000


# top and tail a ps file generated by pyx
def strippsfile(psfile, psout):
    infile = open(psfile)
    outfile = open(psout, "w")
    lines = infile.readlines()
    lines = lines[17:-6]
    for line in lines:
        outfile.write(line)
    infile.close()
    outfile.close()

# write out a canvas as a ps files
def flush(ca, name):
    posterformat = document.paperformat(unit.length(36, unit="inch"),unit.length(36, unit="inch"))
    p = document.page(ca, paperformat = posterformat, centered = 0)
    #p = document.page(ca, paperformat = document.paperformat.A4, fittosize=1, centered=1)
    d = document.document(pages = [p])
    d.writePSfile(name)

# combine all the individual sets with the label file to produce the final output
def combine(pages, n=n):
    labelfile = open("label.ps")
    outfile = open("spiral.ps", "w")
    labellines = labelfile.readlines()
    labelfile.close()
    for line in labellines[0:15]:
        outfile.write(line)
    xtrans = 2592/2.
    ytrans = 2592/2.
    outfile.write("{x:.5f} {y:.5f} translate\n".format(x = xtrans, y = ytrans))

    for line in labellines[15:-4]:
        outfile.write(line)

    for i in range(pages):
        infile = open("tt_spiral%03d.ps" % (i,))

        #write_ps_transformation(i, outfile)
        outfile.write("/pgsave save def\n")
        ###############

        lines = infile.readlines()
        for line in lines[15:-4]:
            outfile.write(line)
        infile.close()
    for line in labellines[-4:]:
        outfile.write(line)
    outfile.close()

def write_ps_transformation(pageNum, outputFile,  n=n):
    overall_radius = math.sqrt(float(n) / math.pi)
    part_radius = math.sqrt(10000. * (pageNum+1) / math.pi)
    scale_factor = part_radius/overall_radius*(10.8/12)

    # Assuming A4 for now
    #x_translation = (595./2.)*(1. - scale_factor)
    #y_translation = (841./2.)*(1. - scale_factor)
    #translation_line = "{0:.5f} {1:.5f} translate\n".format(x_translation, y_translation)
    #scale_line = "{s:.5f} {s:.5f} scale\n".format(s = scale_factor)

    # Assuming Poster Size
    x_translation = (1728./2.)*(1. - scale_factor)
    y_translation = (1728./2.)*(1. - scale_factor)
    translation_line = "{0:.5f} {1:.5f} translate\n".format(x_translation, y_translation)
    scale_line = "{s:.5f} {s:.5f} scale\n".format(s = scale_factor)

    outputFile.write("%NEWPAGE\n")
    outputFile.write("/pgsave save def\n")
    outputFile.write(translation_line)
    outputFile.write(scale_line)


def write_label(ca):
    global n

    #write out the label at bottom left corner
    label_text = r'\begin{minipage}{6in} \begin{center} {\Huge The Sacks Spiral} \vskip 0.05in \hrule \vskip 0.05in \
            \Large $N=' + str(n)+r'$ \end{center} \large Numbers from 1 to ' +str(n)+r', are arranged \
            in a spiral formation. Numbers wind out in a counterclockwise Archimedian spiral, \
            beginning with 0 in the center. Each number is drawn only if it is composite, and bigger dots have more \
            prime factors. For example, $6 = 2 \cdot 3$ has $2$ prime factors, $2$ and $3$, while $8 = 2^3$ has only \
            $2$ as a prime factor. So $6$ is drawn bigger than $8$. The polar coordinates of each number $n$ are  \
            $r = \sqrt{n}, \theta = 2\pi\sqrt{n}$, so that the squares $(1,~4,~9,~16,~25,\ldots)$ form a straight \
            line heading east of the center.  This is a modified version of the \textit{Sacks Spiral} (developed \
            by Robert Sacks in 1994), which is a modified version of the \textit{Ulam Spiral}, discovered by \
            Stanislaw Ulam in 1963.  \vskip 0.05in \hrule \vskip 0.10in \begin{center} \
            \textsc{David Lowry-Duda} \\ \normalsize \textsc{davidlowryduda.com} \end{center} \end{minipage}'

    t = text.latexrunner()
    #t.preamble(r'\usepackage{palatino}')
    ca.insert(t.text(14 ,-15 , label_text,[text.halign.boxcenter, text.valign.middle]))



def draw_axis(ca):
    #init the latex code
    t = text.latexrunner()
    #t.preamble(r'\usepackage{palatino}')

    #radius of the render circle
    insize = 17

    # draw the bounding box
    ca.stroke(path.rect(-17.5,-17.5,35,35))

    # draw the tenth of degree ticks
    for i in range(3600):


        #angle in radians
        ang = (i * math.pi) / 1800.0

        #base size of ticks
        width = 0.001
        outsize = 0.1

        #scaling for each major tick step level
        wscale = 2
        oscale = 1.6



        #compute tick width and length
        if i%900 == 0:
            width *= wscale
            outsize*=oscale

        if i%450 == 0:
            width *= wscale
            outsize*=oscale

        if i%50 == 0:
            width *= wscale
            outsize*=oscale

        if i%10 == 0:
            width *=wscale
            outsize *=oscale


        lw = style.linewidth(unit.length(width, type="w", unit="cm"))

        # compute tick co-ordinates (inner and outer)
        x1 = math.cos(ang) * insize
        y1 = -math.sin(ang) * insize

        x2 = math.cos(ang) * (insize+outsize)
        y2 = -math.sin(ang) * (insize+outsize)


        ca.stroke(path.line(x1,y1,x2,y2), [lw])

        #compute label co-ordinates
        x3 = math.cos(ang) * (insize+outsize+0.1)
        y3 = -math.sin(ang) * (insize+outsize+0.1)

        #write on labels
        if i%900==0:
            ca.insert(t.text(x3,y3,"\\normalsize"+str(i/10),[text.halign.boxcenter, text.valign.middle]))
        elif i%450==0:
            ca.insert(t.text(x3,y3,"\\small"+str(i/10),[text.halign.boxcenter, text.valign.middle]))
        elif i%50==0:
            ca.insert(t.text(x3,y3,"\\footnotesize"+str(i/10),[text.halign.boxcenter, text.valign.middle]))


ca = canvas.canvas()



#scale to just fit inside radius 11 circle
basescale = 17 / (math.sqrt(n)+1)

unit.set(defaultunit="inch")

#init variables
pi2 = 2*math.pi
ctr = 0
pages = 0

for j in range(n):
    i = j + 2
    ctr += 1

    # compute co-ordinates
    r = math.sqrt(i)
    theta = r * pi2
    x = math.cos(theta)*r*basescale
    y = math.sin(theta)*r*basescale

   #do exactly n
    if i < n:
        #factor
        factors = factor(i)

        #optional: compute total factors (not just unique ones)
            #n_facs = 0
            #for f in factors:
            #    n_facs += f[1]
            #uniqueness = float(len(factors))/n_facs
        if(len(factors)>1):
            ca.fill(path.circle(x,y, basescale*0.05*math.pow(2,((len(factors)-1)))))
        if(len(factors)==1):
            ca.fill(path.circle(x,y, basescale*0.05*math.pow(2,2)),[color.gray(1.0)])


    #split into chunks
    if ctr>=10000:
        ctr = 0

        #write out image
        flush(ca, "tt_spiral%03d.ps" % (pages,))

        #flush(ca, "te")
        #strip off header
        #strippsfile("te.ps",  "tt_spiral%03d.ps" % (pages,))
        #reinit canvas
        ca = canvas.canvas()
        pages += 1


#draw the label and axes
ca = canvas.canvas()
ca.fill(path.rect(-18,-18,36,36), [color.gray(0.5)])
write_label(ca)
draw_axis(ca)
flush(ca, "label")

# create the combined document
combine(pages)

# clean up junk
os.system("rm tt_spiral*.ps")
os.system("rm label.ps")
#os.system("rm tmp*.dvi")
#os.system("rm tmp*.aux")

""" Licencing (BSD2)
Copyright 2013, 2014, David Lowry-Duda
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""
